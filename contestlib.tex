\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[landscape, twocolumn]{geometry} % enable landscape, two-column layout
\usepackage{amsmath}
\usepackage{listings}
\usepackage{courier}

\renewcommand{\familydefault}{\sfdefault}
\lstset{basicstyle=\footnotesize\ttfamily, breaklines=true}


\begin{document}

\title{C++ contest library}
\author{Miska Kananen}
\date{\today}
\maketitle 

\tableofcontents

\section{Environment and workflow}
\subsection{Compilation script}
\lstinputlisting[language=bash]{src/compilation/build}

\section{General techniques}
\subsection{Bit tricks}

g++ builtin functions:
\begin{itemize}
	\item \verb|__builtin_clz(x)|: number of zeros in the beginning
	\item \verb|__builtin_ctz(x)|: number of zeros in the end
	\item \verb|__builtin_popcount(x)|: number of set bits
	\item \verb|__builtin_parity(x)|: parity of number of ones
\end{itemize}

There are separate functions of form \verb|__builtin_clzll(x)| for 64-bit integers.

Iterate subsets of set s:
\begin{lstlisting}[language=C++]
int cs = 0;
do {
	// process subset cs
} while(cs=(cs-s)&s);
\end{lstlisting}

\section{Data structures}

\subsection{Lazy segment tree}

Implements range add and range sum query in $O(log(n))$. $0$-indexed.

\lstinputlisting[language=C++]{src/lazy_segtree/lazy_segtree.cpp}

\subsection {Sparse segment tree}

Implements point update and range sum query in $O(log (n))$. Memory usage is around $40$ MB with a range of $2^{30} = 10^9$ after $10^5$ operations. $0$-indexed.

\lstinputlisting[language=C++]{src/sparse_segtree/sparse_segtree.cpp}

\subsection {2D segment tree}

Implements point update and subgrid query in $O(log^2(n))$. Grid is $0$-indexed.

\lstinputlisting[language=C++]{src/2d_segtree/2dsegtree.cpp}

\subsection {Treap}

Implements split, merge, kth element, range update and range reverse in $O(log(n))$. Range update adds a value to every element in a subarray. Treap is $1$-indexed.

Note: Memory management tools warn of about 30 MB memory leak for 500 000 elements. This is because nodes are not deleted when exiting program and is irrelevant in a competition. Deleting nodes would slow treap down by a factor of 3.

\lstinputlisting[language=C++]{src/treap/treap.cpp}

\subsection {Indexed set (policy-based data structures)}

Works like \texttt{std::set} but adds support for indices. Set is 0-indexed. Requires g++. Has two additional functions:

\begin{enumerate}
	\item \verb|find_by_order(x)|: return an iterator to element at index $x$
	\item \verb|order_of_key(x)|: return the index that element $x$ has or would have in the set, depending on if it exists
\end{enumerate}

Both functions work in $O(log(n))$.

Changing \texttt{less} to \verb|less_equal| makes the set work like multiset. However, elements can't be removed.

\lstinputlisting[language=C++]{src/pbds/pbds.cpp}

\subsection{Union-find}

Uses path compression, \texttt{id(x)} has amortized time complexity $O(a^{-1}(n))$ where $a^{-1}$ is inverse Ackermann function.

\lstinputlisting[language=C++]{src/unionfind/unionfind.cpp}

\section {Mathematics}

\subsection {Number theory}

\begin{itemize}
	\item Prime factorization of $n$: $p_1^{\alpha_1}p_2^{\alpha_2} \dots p_k^{\alpha_k}$
	\item Number of factors: $\tau(n) = \prod_{i=1}^{k} (\alpha_i+1)$
	\item Sum of factors: $\sigma(n) = \prod_{i=1}^{k} \frac{p_i^{\alpha_i+1}-1}{p_i-1}$
	\item Product of factors: $\mu(n) = n^{\tau(n)/2}$
\end{itemize}

Euler's totient function $\varphi(n)$ $(1, 1, 2, 2, 4, 2, 6, 4, 6, 4, \dots)$: counts numbers coprime with $n$ in range $1 \dots n$

\[
	\varphi(n) =
	\begin{cases}
		n-1 &\text{if $n$ is prime} \\
		\prod_{i=1}^{k} p_i^{a_i-1}(p_i-1) &\text{otherwise}
	\end{cases}
\]

Fermat's theorem: $x^{m-1} \mod m = 1$ when $m$ is prime and $x$ and $m$ are coprime. It follows that $x^k \mod m = x^{k \mod (m-1)} \mod m$.

Modular inverse $x^{-1} = x^{\varphi(m)-1}$. If $m$ is prime, $x^{-1} = x^{m-2}$. Inverse exists if and only if $x$ and $m$ are coprime.

\subsection {Combinatorics}

Binomial coefficients:

\[ \binom{n}{k} = \binom{n-1}{k-1} + \binom{n-1}{k} \]
\[ \binom{n}{0} = \binom{n}{n} = 1 \]

Catalan numbers $(1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796 \dots)$:

\[ C_n = \frac{1}{n+1} \binom{2n}{n} \]

Classic examples of Catalan numbers: number of balanced pairs of parentheses,  number of mountain ranges ($n$ upstrokes and $n$ downstrokes all staying above the original line), number of paths from upper left corner to lower right corner staying above the main diagonal in a $n \times n$ square, ways to trianguate a $n+2$ sided regular polygon, ways to shake hands between $2n$ people in a circle such that no arms cross, number of rooted binary trees with $n$ nodes that have $2$ children, number of rooted trees with $n$ edges, number of permutations of $1 \dots n$ that don't have an increasing subsequence of length $3$.

Number of derangements (no element stays in original place) of $1, 2, \dots, n$ $(1, 0, 1, 2, 9, 44, 265, 1854, 14833, 133496, 1334961, \dots)$:

\[
	f(n) =
	\begin{cases}
		0 &n = 1 \\
		1 &n = 2 \\
		(n-1)(f(n-2)+f(n-1)) &n > 2
	\end{cases}
\]

\subsection {Matrices}

Matrix $A$ = $a \times n$, matrix $B$ = $n \times b$. Matrix multiplication:

\[ AB[i,j] = \sum_{k=1}^{n} A[i,k] \cdot B[k,j] \]

Let linear recurrence $f(n) = c_1f(n-1) + c_2f(n-2) + \dots + c_kf(n-k)$ with initial values $f(0), f(1), \dots, f(k-1)$. $c_1, c_2, \dots, c_n$ are constants.

Transition matrix $X$:

\[
	X =
	\begin{pmatrix}
		0 & 1 & 0 & \dots & 0 \\
		0 & 0 & 1 & \dots & 0 \\
		\vdots & \vdots & \vdots & \ddots & \vdots \\
		0 & 0 & 0 & \dots & 1 \\
		c_k & c_{k-1} & c_{k-2} & \dots & c_1
	\end{pmatrix}
\]

Now $f(n)$ can be calculated in $O(k^3 log(n))$:

\[
	\begin{pmatrix}
		f(n) \\
		f(n+1) \\
		\vdots \\
		f(n+k-1)
	\end{pmatrix}
	= X^n \cdot
	\begin{pmatrix}
		f(0) \\
		f(1) \\
		\vdots \\
		f(k-1)
	\end{pmatrix}
\]

\lstinputlisting[language=C++]{src/matrix/matrix.cpp}

\subsection {Miller-Rabin}

Deterministic primality test for all $64$-bit integers. Requires \verb|__int128| support to test over 32-bit integers.

\subsection {Pollard-Rho}

Finds a prime factor of $x$ in $O(\sqrt[4]{x})$. Requires \verb|__int128| support to factor over 32-bit integers.

If $x$ is prime, algorithm might not terminate or it might return $1$. Primality must be checked separately.

\lstinputlisting[language=C++]{src/pollardrho/pollardrho.cpp}

\section {Geometry}

\subsection {Geometric primitives}
\subsubsection {Representations}
\subsubsection {Polygon area}
\subsubsection {Point in a polygon}

\subsection {Intersections}
\subsubsection {Line-line}
\subsubsection {Line-circle}

\subsection {Convex hull}

\section {Graph algorithms}

\subsection {Kosaraju's algorithm}

Finds strongly connected components in a directed graph in $O(n + m)$.

\begin{enumerate}
	\item Create an inverse graph where all edges are reversed.
	\item Do a DFS traversal on original graph and add all nodes in post-order to a vector.
	\item Reverse the previous vector.
	\item Iterate the vector. If a node doesn't belong to a component, create new component and assign current node to it, and do a DFS search \textbf{in inverse graph} from current node and add all reachable nodes to the component that was just created.
\end{enumerate}

\subsection {Bridges}

An edge $u-v$ is a bridge if there is no edge from the subtree of $v$ to any node with lower depth than $u$ in DFS tree. $O(n+m)$.

\lstinputlisting[language=C++]{src/bridges/bridges.cpp}

\subsection {Articulation points}

A vertex $u$ is an articulation point if there is no edge from the subtree of $u$ to any parent of $u$ in DFS tree, of if $u$ is the root of DFS tree and has at least $2$ children. $O(n+m)$ if removing duplicates doesn't count.

Set \texttt{res} can be replaced with a vector if duplicates are removed afterwards.

\lstinputlisting[language=C++]{src/articulation_points/articulation_points.cpp}

\subsection {Maximum flow (scaling algorithm)}

Scaling algorithm, uses DFS to find an augmenting path where each edge weight is larger than or equal to a certain threshold. Time complexity $O(m^2log(c))$, where c is the starting threshold (sum of all edge weights on the graph).

\lstinputlisting[language=C++]{src/maxflow/maxflow.cpp}

\subsection {Theorems on flows and cuts}

Maximum flow is always equal to minimum cut. Minimum cut can be found by running a maximum flow algorithm and dividing the resulting flow graph into two sets of vertices. Set A contains all vertices that can be reached from source using positive-weight edges. Set B contains all other vertices. Minimum cut consists of the edges between these two sets.

Number of edge-disjoint (= each edge can be used at most once) paths in a graph is equal to maximum flow on graph where capacity of each edge is $1$.

Number of vertex-disjoint paths can be found the same way as edge-disjoint paths, but each vertex is duplicated and an edge is added between the two vertices. All incoming edges go to the first vertex and all outgoing edges start from the second vertex.

Maximum matching of a bipartite graph can be found by adding a source and a sink to the graph and connecting source to all left vertices and sink to all right vertices. Maximum matching equals maximum flow on this graph.

KÃ¶nig's theorem: sizes of a minimum vertex cover (= minimum set of vertices such that each edge has at least one endpoint in the set) and a maximum matching are always equal in a bipartite graph. Maximum independent set (= maximum set of vertices such that no two vertices in the set are connected with an edge) consists of the vertices not in a minimum vertex cover.

\subsection {Heavy-light decomposition}

Supports updates and queries on path between two vertices $a$ and $b$ in $O(log^2(n))$.

Doesn't explicitly look for LCA, instead climbs upwards from the lower chain until both vertices are in the same chain.

Requires a segment tree implementation that corresponds to the queries. Lazy segtree, for example, can be pasted directly in.

\lstinputlisting[language=C++]{src/hld/hld.cpp}

\section {String algorithms}

\subsection {Polynomial hashing}

If hash collisions are likely, compute two hashes with two distinct pairs of constants of magnitude $10^9$ and use their product as the actual hash.

\lstinputlisting[language=C++]{src/stringhashing/stringhashing.cpp}


\end{document}